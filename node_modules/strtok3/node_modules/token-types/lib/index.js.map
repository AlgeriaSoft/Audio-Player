{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["// A fast streaming parser library.\n\nimport * as assert from 'assert';\n\n// Possibly call flush()\nconst maybeFlush = (b, o, len, flush) => {\n    if (o + len > b.length) {\n        if (typeof(flush) !== 'function') {\n            throw new Error(\n                'Buffer out of space and no valid flush() function found'\n            );\n        }\n\n        flush(b, o);\n\n        return 0;\n    }\n\n    return o;\n};\n\nexport interface IGetToken<T> {\n\n    /**\n     * Length in bytes of encoded value\n     */\n    len: number;\n\n    /**\n     * Decode value from buffer at offset\n     * @param buf Buffer to read the decoded value from\n     * @param off Decode offset\n     */\n    get(buf: Buffer, off: number): T;\n}\n\nexport interface IToken<T> extends IGetToken<T> {\n    /**\n     * Encode value to buffer\n     * @param buffer Buffer to write the encoded value to\n     * @param offset Buffer write offset\n     * @param value Value to decode of type T\n     * @param flush ToDo\n     */\n    put(buffer: Buffer, offset: number, value: T, flush?: IFlush): number\n}\n\nexport type IFlush = (b: Buffer, o: number) => void;\n\n// Primitive types\n\n/**\n * 8-bit unsigned integer\n */\nexport const UINT8: IToken<number> = {\n\n    len: 1,\n\n    get(buf: Buffer, off: number): number {\n        return buf[off];\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 16-bit unsigned integer, Little Endian byte order\n */\nexport const UINT16_LE: IToken<number> = {\n\n    len: 2,\n\n    get(buf: Buffer, off: number): number {\n        return buf[off] | (buf[off + 1] << 8);\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = v & 0xff;\n        b[no + 1] = (v >>> 8) & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 16-bit unsigned integer, Big Endian byte order\n */\nexport const UINT16_BE: IToken<number> = {\n\n    len: 2,\n\n    get(buf: Buffer, off: number): number {\n        return (buf[off] << 8) | buf[off + 1];\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = (v >>> 8) & 0xff;\n        b[no + 1] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 24-bit unsigned integer, Little Endian byte order\n */\nexport const UINT24_LE: IToken<number> = {\n\n    len: 3,\n\n    get(buf: Buffer, off: number): number {\n        return buf[off] | (buf[off + 1] << 8) | (buf[off + 2] << 16);\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = v & 0xff;\n        b[no + 1] = (v >>> 8) & 0xff;\n        b[no + 2] = (v >>> 16) & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 24-bit unsigned integer, Big Endian byte order\n */\nexport const UINT24_BE: IToken<number> = {\n    len : 3,\n    get(buf: Buffer, off: number): number {\n        return (((buf[off] << 8) + buf[off + 1]) << 8) + buf[off + 2]\n    },\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = (v >>> 16) & 0xff;\n        b[no + 1] = (v >>> 8) & 0xff;\n        b[no + 2] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 32-bit unsigned integer, Little Endian byte order\n */\nexport const UINT32_LE: IToken<number> = {\n\n    len: 4,\n\n    get(buf: Buffer, off: number): number {\n        // Shifting the MSB by 24 directly causes it to go negative if its\n        // last bit is high, so we instead shift by 23 and multiply by 2.\n        // Also, using binary OR to count the MSB if its last bit is high\n        // causes the value to go negative. Use addition there.\n        return (buf[off] | (buf[off + 1] << 8) | (buf[off + 2] << 16)) +\n            ((buf[off + 3] << 23) * 2);\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = v & 0xff;\n        b[no + 1] = (v >>> 8) & 0xff;\n        b[no + 2] = (v >>> 16) & 0xff;\n        b[no + 3] = (v >>> 24) & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 32-bit unsigned integer, Big Endian byte order\n */\nexport const UINT32_BE: IToken<number> = {\n\n    len: 4,\n\n    get(buf: Buffer, off: number): number {\n        // See comments in UINT32_LE.get()\n        return ((buf[off] << 23) * 2) +\n            ((buf[off + 1] << 16) | (buf[off + 2] << 8) | buf[off + 3]);\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= 0 && v <= 0xffffffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = (v >>> 24) & 0xff;\n        b[no + 1] = (v >>> 16) & 0xff;\n        b[no + 2] = (v >>> 8) & 0xff;\n        b[no + 3] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 8-bit signed integer\n */\nexport const INT8: IToken<number> = {\n\n    len: 1,\n\n    get(buf: Buffer, off: number): number {\n        const v = UINT8.get(buf, off);\n        return ((v & 0x80) === 0x80) ?\n            (-128 + (v & 0x7f)) :\n            v;\n    },\n\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -128 && v <= 127);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 16-bit signed integer, Big Endian byte order\n */\nexport const INT16_BE: IToken<number> = {\n    len: 2,\n    get(buf: Buffer, off: number): number {\n        const v = UINT16_BE.get(buf, off);\n        return ((v & 0x8000) === 0x8000) ?\n            (-32768 + (v & 0x7fff)) :\n            v;\n    },\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -32768 && v <= 32767);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = ((v & 0xffff) >>> 8) & 0xff;\n        b[no + 1] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 24-bit signed integer, Big Endian byte order\n */\nexport const INT24_BE: IToken<number> = {\n    len: 3,\n    get(buf: Buffer, off: number): number {\n        const v = UINT24_BE.get(buf, off);\n        return ((v & 0x800000) === 0x800000) ?\n            (-0x800000 + (v & 0x7fffff)) : v;\n    },\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -0x800000 && v <= 0x7fffff);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = (v >>> 16) & 0xff;\n        b[no + 1] = (v >>> 8) & 0xff;\n        b[no + 2] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * 32-bit signed integer, Big Endian byte order\n */\nexport const INT32_BE: IToken<number> = {\n    len: 4,\n    get(buf: Buffer, off: number): number {\n        // We cannot check for 0x80000000 directly, as this always returns\n        // false. Instead, check for the two's-compliment value, which\n        // behaves as expected. Also, we cannot subtract our value all at\n        // once, so do it in two steps to avoid sign busting.\n        const v = UINT32_BE.get(buf, off);\n        return ((v & 0x80000000) === -2147483648) ?\n            ((v & 0x7fffffff) - 1073741824 - 1073741824) :\n            v;\n    },\n    put(b: Buffer, o: number, v: number, flush?: IFlush): number {\n        assert.equal(typeof o, 'number');\n        assert.equal(typeof v, 'number');\n        assert.ok(v >= -2147483648 && v <= 2147483647);\n        assert.ok(o >= 0);\n        assert.ok(this.len <= b.length);\n\n        const no = maybeFlush(b, o, this.len, flush);\n        b[no] = (v >>> 24) & 0xff;\n        b[no + 1] = (v >>> 16) & 0xff;\n        b[no + 2] = (v >>> 8) & 0xff;\n        b[no + 3] = v & 0xff;\n\n        return (no - o) + this.len;\n    }\n};\n\n/**\n * Ignore a given number of bytes\n */\nexport class IgnoreType implements IGetToken<Buffer> {\n\n    /**\n     * @param len number of bytes to ignore\n     */\n    constructor(public len: number) {\n    }\n\n    // ToDo: don't read, but skip data\n    public get(buf: Buffer, off: number): Buffer {\n        return null;\n    }\n}\n\n\nexport class BufferType implements IGetToken<Buffer> {\n\n    public constructor(public len: number) {\n    }\n\n    public get(buf: Buffer, off: number): Buffer {\n        return buf.slice(off, off + this.len);\n    }\n}\n\n/**\n * Consume a fixed number of bytes from the stream and return a string with a specified encoding.\n */\nexport class StringType implements IGetToken<string> {\n\n    public constructor(public len: number, public encoding: string) {\n    }\n\n    public get(buf: Buffer, off: number): string {\n        return buf.toString(this.encoding, off, off + this.len);\n    }\n}\n\n"]}