"use strict";
exports.__esModule = true;
var Token = require("token-types");
var chai_1 = require("chai");
var util_1 = require("./util");
var strtok3 = require("../src");
var Path = require("path");
var token_types_1 = require("token-types");
var fs = require("fs-extra");
describe("ReadStreamTokenizer", function () {
    describe("buffer", function () {
        var ss = new util_1.SourceStream('\x05peter');
        return strtok3.fromStream(ss).then(function (rst) {
            it("should decode UINT8 from chunk", function () {
                return rst.readToken(Token.UINT8).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 5, "0x05 == 5");
                });
            });
            it("should decode string from chunk", function () {
                return rst.readToken(new Token.StringType(5, 'utf-8')).then(function (value) {
                    chai_1.assert.ok(typeof value === 'string');
                    chai_1.assert.equal(value, 'peter', "0x05 == 5");
                });
            });
            it("should should reject at the end of the stream", function () {
                return rst.readToken(Token.UINT8).then(function () {
                    chai_1.assert.fail("Should rejct due to end-of-stream");
                })["catch"](function (err) {
                    chai_1.assert.equal(err, strtok3.EndOfFile);
                });
            });
        });
    });
    it("should contain fileSize if constructed from file-read-stream", function () {
        // ToDo
        var fileReadStream = fs.createReadStream(Path.join(__dirname, 'resources', 'test1.dat'));
        return strtok3.fromStream(fileReadStream).then(function (rst) {
            chai_1.assert.equal(rst.fileSize, 16, " ReadStreamTokenizer.fileSize");
            fileReadStream.close();
        });
    });
    describe("Parsing binary numbers", function () {
        it("should encode signed 8-bit integer (INT8)", function () {
            var b = new Buffer(1);
            Token.INT8.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00');
            Token.INT8.put(b, 0, 0x22);
            chai_1.assert.strictEqual(b.toString('binary'), '\x22');
            Token.INT8.put(b, 0, -0x22);
            chai_1.assert.strictEqual(b.toString('binary'), '\xde');
        });
        it("should decode signed 8-bit integer (INT8)", function () {
            var ss = new util_1.SourceStream('\x00\x7f\x80\xff\x81');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.INT8)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0, "INT8 #1 == 0");
                    return rst.readToken(Token.INT8);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 127, "INT8 #2 == 127");
                    return rst.readToken(Token.INT8);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -128, "INT8 #3 == -128");
                    return rst.readToken(Token.INT8);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -1, "INT8 #4 == -1");
                    return rst.readToken(Token.INT8);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -127, "INT8 #5 == -127");
                });
            });
        });
        it("should encode signed 16-bit big-endian integer (INT16_BE)", function () {
            var b = new Buffer(2);
            Token.INT16_BE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00');
            Token.INT16_BE.put(b, 0, 0x0f0b);
            chai_1.assert.strictEqual(b.toString('binary'), '\x0f\x0b');
            Token.INT16_BE.put(b, 0, -0x0f0b);
            chai_1.assert.strictEqual(b.toString('binary'), '\xf0\xf5');
        });
        it("should decode signed 16-bit big-endian integer (INT16_BE)", function () {
            var ss = new util_1.SourceStream('\x0a\x1a\x00\x00\xff\xff\x80\x00');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.INT16_BE)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 2586, "INT16_BE#1");
                    return rst.readToken(Token.INT16_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0, "INT16_BE#2");
                    return rst.readToken(Token.INT16_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -1, "INT16_BE#3");
                    return rst.readToken(Token.INT16_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -32768, "INT16_BE#4");
                });
            });
        });
        it("should encode signed 24-bit big-endian integer (INT24_BE)", function () {
            var b = new Buffer(3);
            Token.INT24_BE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00');
            Token.INT24_BE.put(b, 0, 0x0f0ba0);
            chai_1.assert.strictEqual(b.toString('binary'), '\x0f\x0b\xa0');
            Token.INT24_BE.put(b, 0, -0x0f0bcc);
            chai_1.assert.strictEqual(b.toString('binary'), '\xf0\xf4\x34');
        });
        it("should decode signed 24-bit big-endian integer (INT24_BE)", function () {
            var ss = new util_1.SourceStream('\x00\x00\x00\xff\xff\xff\x10\x00\xff\x80\x00\x00');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.INT24_BE)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0, "INT24_BE#1");
                    return rst.readToken(Token.INT24_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -1, "INT24_BE#2");
                    return rst.readToken(Token.INT24_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 1048831, "INT24_BE#3");
                    return rst.readToken(Token.INT24_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -8388608, "INT24_BE#4");
                });
            });
        });
        // ToDo: test decoding: INT24_LE
        it("should encode signed 32-bit big-endian integer (INT32_BE)", function () {
            var b = new Buffer(4);
            Token.INT32_BE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00\x00');
            Token.INT32_BE.put(b, 0, 0x0f0bcca0);
            chai_1.assert.strictEqual(b.toString('binary'), '\x0f\x0b\xcc\xa0');
            Token.INT32_BE.put(b, 0, -0x0f0bcca0);
            chai_1.assert.strictEqual(b.toString('binary'), '\xf0\xf4\x33\x60');
        });
        it("should decode signed 32-bit big-endian integer (INT32_BE)", function () {
            var ss = new util_1.SourceStream('\x00\x00\x00\x00\xff\xff\xff\xff\x00\x10\x00\xff\x80\x00\x00\x00');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.INT32_BE)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0, "INT24_BE #1");
                    return rst.readToken(Token.INT32_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -1, "INT32_BE #2");
                    return rst.readToken(Token.INT32_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 1048831, "INT32_BE #3");
                    return rst.readToken(Token.INT32_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, -2147483648, "INT32_BE #4");
                });
            });
        });
        it("should encode signed 8-bit big-endian integer (INT8)", function () {
            var b = new Buffer(1);
            Token.UINT8.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00');
            Token.UINT8.put(b, 0, 0xff);
            chai_1.assert.strictEqual(b.toString('binary'), '\xff');
        });
        it("should decode unsigned 8-bit big-endian integer (UINT8)", function () {
            var ss = new util_1.SourceStream('\x00\x1a\xff');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.UINT8)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0, "UINT8 #1");
                    return rst.readToken(Token.UINT8);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 26, "UINT8 #2");
                    return rst.readToken(Token.UINT8);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 255, "UINT8 #3");
                });
            });
        });
        it("should encode unsigned 16-bit big-endian integer (UINT16_LE)", function () {
            var b = new Buffer(4);
            Token.UINT16_LE.put(b, 0, 0x00);
            Token.UINT16_LE.put(b, 2, 0xffaa);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\xaa\xff');
        });
        it("should encode unsigned 16-bit little-endian integer (UINT16_BE)", function () {
            var b = new Buffer(4);
            Token.UINT16_BE.put(b, 0, 0xf);
            Token.UINT16_BE.put(b, 2, 0xffaa);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x0f\xff\xaa');
        });
        it("should encode unsigned 16-bit mixed little/big-endian integers", function () {
            var b = new Buffer(4);
            Token.UINT16_BE.put(b, 0, 0xffaa);
            Token.UINT16_LE.put(b, 2, 0xffaa);
            chai_1.assert.strictEqual(b.toString('binary'), '\xff\xaa\xaa\xff');
        });
        it("should decode unsigned mixed 16-bit big/little-endian integer", function () {
            var ss = new util_1.SourceStream('\x1a\x00\x1a\x00\x1a\x00\x1a\x00');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.UINT16_LE)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x001a, "UINT16_LE #1");
                    return rst.readToken(Token.UINT16_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x1a00, "UINT16_BE #2");
                    return rst.readToken(Token.UINT16_LE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x001a, "UINT16_BE #3");
                    return rst.readToken(Token.UINT16_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x1a00, "UINT16_LE #4");
                });
            });
        });
        it("should encode unsigned 24-bit little-endian integer (UINT24_LE)", function () {
            var b = new Buffer(3);
            Token.UINT24_LE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00');
            Token.UINT24_LE.put(b, 0, 0xff);
            chai_1.assert.strictEqual(b.toString('binary'), '\xff\x00\x00');
            Token.UINT24_LE.put(b, 0, 0xaabbcc);
            chai_1.assert.strictEqual(b.toString('binary'), '\xcc\xbb\xaa');
        });
        it("should encode unsigned 24-bit big-endian integer (UINT24_BE)", function () {
            var b = new Buffer(3);
            Token.UINT24_BE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00');
            Token.UINT24_BE.put(b, 0, 0xff);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\xff');
            Token.UINT24_BE.put(b, 0, 0xaabbcc);
            chai_1.assert.strictEqual(b.toString('binary'), '\xaa\xbb\xcc');
        });
        it("should decode signed 24-bit big/little-endian integer (UINT24_LE/INT24_BE)", function () {
            var ss = new util_1.SourceStream('\x1a\x1a\x00\x1a\x1a\x00\x1a\x1a\x00\x1a\x1a\x00');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.UINT24_LE)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x001a1a, "INT24_LE#1");
                    return rst.readToken(Token.UINT24_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x1a1a00, "INT24_BE#2");
                    return rst.readToken(Token.UINT24_LE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x001a1a, "INT24_LE#3");
                    return rst.readToken(Token.UINT24_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x1a1a00, "INT24_BE#4");
                });
            });
        });
        it("should encode unsigned 32-bit little-endian integer (UINT32_LE)", function () {
            var b = new Buffer(4);
            Token.UINT32_LE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00\x00');
            Token.UINT32_LE.put(b, 0, 0xff);
            chai_1.assert.strictEqual(b.toString('binary'), '\xff\x00\x00\x00');
            Token.UINT32_LE.put(b, 0, 0xaabbccdd);
            chai_1.assert.strictEqual(b.toString('binary'), '\xdd\xcc\xbb\xaa');
        });
        it("should encode unsigned 32-bit big-endian integer (INT32_BE)", function () {
            var b = new Buffer(4);
            Token.UINT32_BE.put(b, 0, 0x00);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00\x00');
            Token.UINT32_BE.put(b, 0, 0xff);
            chai_1.assert.strictEqual(b.toString('binary'), '\x00\x00\x00\xff');
            Token.UINT32_BE.put(b, 0, 0xaabbccdd);
            chai_1.assert.strictEqual(b.toString('binary'), '\xaa\xbb\xcc\xdd');
        });
        it("should decode unsigned 32-bit little/big-endian integer (UINT32_LE/UINT32_BE)", function () {
            var ss = new util_1.SourceStream('\x1a\x00\x1a\x00\x1a\x00\x1a\x00\x1a\x00\x1a\x00\x1a\x00\x1a\x00');
            return strtok3.fromStream(ss).then(function (rst) {
                return rst.readToken(Token.UINT32_LE)
                    .then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x001a001a, "UINT24_LE #1");
                    return rst.readToken(Token.UINT32_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #2");
                    return rst.readToken(Token.UINT32_LE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x001a001a, "UINT32_LE #3");
                    return rst.readToken(Token.UINT32_BE);
                }).then(function (value) {
                    chai_1.assert.ok(typeof value === 'number');
                    chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #4");
                });
            });
        });
    });
});
describe("FileTokenizer", function () {
    it("should be able to read from a file", function () {
        return strtok3.fromFile(Path.join(__dirname, 'resources', 'test1.dat')).then(function (tokenizer) {
            chai_1.assert.equal(tokenizer.fileSize, 16, "check file size property");
            return tokenizer.readToken(Token.UINT32_LE)
                .then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x001a001a, "UINT24_LE #1");
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #2");
                return tokenizer.readToken(Token.UINT32_LE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x001a001a, "UINT32_LE #3");
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #4");
            });
        });
    });
    it("should be able to ignore (skip) a given number of bytes", function () {
        return strtok3.fromFile(Path.join(__dirname, 'resources', 'test1.dat')).then(function (tokenizer) {
            return tokenizer.ignore(4)
                .then(function () {
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #2");
                return tokenizer.readToken(Token.UINT32_LE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x001a001a, "UINT32_LE #3");
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #4");
            });
        });
    });
    it("should be able to handle multiple ignores", function () {
        return strtok3.fromFile(Path.join(__dirname, 'resources', 'test1.dat')).then(function (tokenizer) {
            return tokenizer.readToken(Token.UINT32_LE)
                .then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x001a001a, "UINT24_LE #1");
                return tokenizer.ignore(Token.UINT32_BE.len);
            }).then(function () {
                return tokenizer.ignore(Token.UINT32_LE.len);
            }).then(function () {
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #4");
            });
        });
    });
    it("should be able to parse the IgnoreType-token", function () {
        return strtok3.fromFile(Path.join(__dirname, 'resources', 'test1.dat')).then(function (tokenizer) {
            return tokenizer.readToken(new token_types_1.IgnoreType(4))
                .then(function () {
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #2");
                return tokenizer.readToken(Token.UINT32_LE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x001a001a, "UINT32_LE #3");
                return tokenizer.readToken(Token.UINT32_BE);
            }).then(function (value) {
                chai_1.assert.ok(typeof value === 'number');
                chai_1.assert.equal(value, 0x1a001a00, "UINT32_BE #4");
            });
        });
    });
});
