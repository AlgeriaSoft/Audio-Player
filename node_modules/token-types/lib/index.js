"use strict";
// A fast streaming parser library.
exports.__esModule = true;
var assert = require("assert");
// Possibly call flush()
var maybeFlush = function (b, o, len, flush) {
    if (o + len > b.length) {
        if (typeof (flush) !== 'function') {
            throw new Error('Buffer out of space and no valid flush() function found');
        }
        flush(b, o);
        return 0;
    }
    return o;
};
// Primitive types
/**
 * 8-bit unsigned integer
 */
exports.UINT8 = {
    len: 1,
    get: function (buf, off) {
        return buf[off];
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
exports.UINT16_LE = {
    len: 2,
    get: function (buf, off) {
        return buf[off] | (buf[off + 1] << 8);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
exports.UINT16_BE = {
    len: 2,
    get: function (buf, off) {
        return (buf[off] << 8) | buf[off + 1];
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 8) & 0xff;
        b[no + 1] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 24-bit unsigned integer, Little Endian byte order
 */
exports.UINT24_LE = {
    len: 3,
    get: function (buf, off) {
        return buf[off] | (buf[off + 1] << 8) | (buf[off + 2] << 16);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = (v >>> 16) & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 24-bit unsigned integer, Big Endian byte order
 */
exports.UINT24_BE = {
    len: 3,
    get: function (buf, off) {
        return (((buf[off] << 8) + buf[off + 1]) << 8) + buf[off + 2];
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 16) & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
exports.UINT32_LE = {
    len: 4,
    get: function (buf, off) {
        // Shifting the MSB by 24 directly causes it to go negative if its
        // last bit is high, so we instead shift by 23 and multiply by 2.
        // Also, using binary OR to count the MSB if its last bit is high
        // causes the value to go negative. Use addition there.
        return (buf[off] | (buf[off + 1] << 8) | (buf[off + 2] << 16)) +
            ((buf[off + 3] << 23) * 2);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = (v >>> 16) & 0xff;
        b[no + 3] = (v >>> 24) & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
exports.UINT32_BE = {
    len: 4,
    get: function (buf, off) {
        // See comments in UINT32_LE.get()
        return ((buf[off] << 23) * 2) +
            ((buf[off + 1] << 16) | (buf[off + 2] << 8) | buf[off + 3]);
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= 0 && v <= 0xffffffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 24) & 0xff;
        b[no + 1] = (v >>> 16) & 0xff;
        b[no + 2] = (v >>> 8) & 0xff;
        b[no + 3] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 8-bit signed integer
 */
exports.INT8 = {
    len: 1,
    get: function (buf, off) {
        var v = exports.UINT8.get(buf, off);
        return ((v & 0x80) === 0x80) ?
            (-128 + (v & 0x7f)) :
            v;
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -128 && v <= 127);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 16-bit signed integer, Big Endian byte order
 */
exports.INT16_BE = {
    len: 2,
    get: function (buf, off) {
        var v = exports.UINT16_BE.get(buf, off);
        return ((v & 0x8000) === 0x8000) ?
            (-32768 + (v & 0x7fff)) :
            v;
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -32768 && v <= 32767);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = ((v & 0xffff) >>> 8) & 0xff;
        b[no + 1] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 24-bit signed integer, Big Endian byte order
 */
exports.INT24_BE = {
    len: 3,
    get: function (buf, off) {
        var v = exports.UINT24_BE.get(buf, off);
        return ((v & 0x800000) === 0x800000) ?
            (-0x800000 + (v & 0x7fffff)) : v;
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -0x800000 && v <= 0x7fffff);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 16) & 0xff;
        b[no + 1] = (v >>> 8) & 0xff;
        b[no + 2] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
exports.INT32_BE = {
    len: 4,
    get: function (buf, off) {
        // We cannot check for 0x80000000 directly, as this always returns
        // false. Instead, check for the two's-compliment value, which
        // behaves as expected. Also, we cannot subtract our value all at
        // once, so do it in two steps to avoid sign busting.
        var v = exports.UINT32_BE.get(buf, off);
        return ((v & 0x80000000) === -2147483648) ?
            ((v & 0x7fffffff) - 1073741824 - 1073741824) :
            v;
    },
    put: function (b, o, v, flush) {
        assert.equal(typeof o, 'number');
        assert.equal(typeof v, 'number');
        assert.ok(v >= -2147483648 && v <= 2147483647);
        assert.ok(o >= 0);
        assert.ok(this.len <= b.length);
        var no = maybeFlush(b, o, this.len, flush);
        b[no] = (v >>> 24) & 0xff;
        b[no + 1] = (v >>> 16) & 0xff;
        b[no + 2] = (v >>> 8) & 0xff;
        b[no + 3] = v & 0xff;
        return (no - o) + this.len;
    }
};
/**
 * Ignore a given number of bytes
 */
var IgnoreType = (function () {
    /**
     * @param len number of bytes to ignore
     */
    function IgnoreType(len) {
        this.len = len;
    }
    // ToDo: don't read, but skip data
    IgnoreType.prototype.get = function (buf, off) {
        return null;
    };
    return IgnoreType;
}());
exports.IgnoreType = IgnoreType;
var BufferType = (function () {
    function BufferType(len) {
        this.len = len;
    }
    BufferType.prototype.get = function (buf, off) {
        return buf.slice(off, off + this.len);
    };
    return BufferType;
}());
exports.BufferType = BufferType;
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
var StringType = (function () {
    function StringType(len, encoding) {
        this.len = len;
        this.encoding = encoding;
    }
    StringType.prototype.get = function (buf, off) {
        return buf.toString(this.encoding, off, off + this.len);
    };
    return StringType;
}());
exports.StringType = StringType;
//# sourceMappingURL=index.js.map