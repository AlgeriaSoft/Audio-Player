{"version":3,"file":"ParserFactory.js","sourceRoot":"","sources":["../src/ParserFactory.ts"],"names":[],"mappings":";;AACA,mDAAgD;AAChD,mDAAgD;AAChD,mDAAgD;AAChD,6CAA0C;AAC1C,gDAA6C;AAC7C,6CAA0C;AAC1C,6CAA0C;AAC1C,iCAAmC;AACnC,2CAAuC;AACvC,2CAAoC;AAEpC,2BAA6B;AAC7B,gDAA6C;AAM7C;IAAA;QA6HE,+BAA+B;QACvB,YAAO,GAAa,EAAE,CAAC;IAEjC,CAAC;IA9HC;;;;;;;OAOG;IACW,uBAAS,GAAvB,UAAwB,QAAgB,EAAE,IAAmB;QAAnB,qBAAA,EAAA,SAAmB;QAE3D,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAC,aAAa;YACnD,MAAM,CAAC,aAAa,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAC,MAAM;gBAC/D,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,UAAC,QAAQ;oBACrD,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC;wBAChC,MAAM,CAAC,QAAQ,CAAC;oBAClB,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC,KAAK,CAAC,UAAC,GAAG;gBACX,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC;oBAChC,MAAM,GAAG,CAAC;gBACZ,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACW,yBAAW,GAAzB,UAA0B,MAAuB,EAAE,QAAgB,EAAE,IAAmB;QAAnB,qBAAA,EAAA,SAAmB;QAEtF,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,UAAC,SAAS;YAC/C,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzC,SAAS,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YACrC,CAAC;YAED,MAAM,CAAC,aAAa,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAC,MAAM;gBAC9D,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;YACvC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACY,mCAAqB,GAApC,UAAqC,QAAgB;QACnD,IAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,iBAAiB,EAAE,CAAC;QAC7D,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YAElB,KAAK,MAAM;gBACT,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,UAAC,MAAM;oBACnD,MAAM,CAAC,MAAM,GAAG,IAAI,yBAAW,EAAE,GAAG,IAAI,yBAAW,EAAE,CAAC;gBACxD,CAAC,CAAC,CAAC;YAEL,KAAK,MAAM;gBACT,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,yBAAW,EAAE,CAAC,CAAC;YAE1D,KAAK,MAAM,CAAC;YACZ,KAAK,MAAM,CAAC;YACZ,KAAK,MAAM;gBACT,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD,KAAK,MAAM,CAAC;YACZ,KAAK,MAAM,CAAC;YACZ,KAAK,MAAM;gBACT,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD,KAAK,OAAO;gBACV,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,uBAAU,EAAE,CAAC,CAAC;YAEzD,KAAK,MAAM;gBACT,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD,KAAK,OAAO;gBACV,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,uBAAU,EAAE,CAAC,CAAC;YAEzD;gBACE,MAAM,IAAI,KAAK,CAAC,YAAY,GAAG,SAAS,GAAG,iBAAiB,CAAC,CAAC;QAClE,CAAC;IACH,CAAC;IAEc,kCAAoB,GAAnC,UAAoC,QAAgB;QAClD,MAAM,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YAEjB,KAAK,YAAY;gBACf,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,yBAAW,EAAE,CAAC,CAAC,CAAC,kCAAkC;YAE7F,KAAK,uBAAuB;gBAC1B,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,yBAAW,EAAE,CAAC,CAAC;YAE1D,KAAK,WAAW;gBACd,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD,KAAK,gBAAgB;gBACnB,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD,KAAK,YAAY;gBACf,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,uBAAU,EAAE,CAAC,CAAC;YAEzD,KAAK,WAAW;gBACd,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD,KAAK,WAAW,CAAC;YACjB,KAAK,YAAY;gBACf,MAAM,CAAC,qBAAO,CAAC,OAAO,CAAe,IAAI,qBAAS,EAAE,CAAC,CAAC;YAExD;gBACE,MAAM,IAAI,KAAK,CAAC,aAAa,GAAG,QAAQ,GAAG,iBAAiB,CAAC,CAAC;QAClE,CAAC;IACH,CAAC;IAED,iBAAiB;IACF,yBAAW,GAA1B,UAA2B,QAAgB,EAAE,aAAqB;QAChE,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAC,SAAS;YAC/C,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,wBAAU,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,UAAC,KAAK;gBACnF,MAAM,CAAC,KAAK,KAAK,aAAa,CAAC;YACjC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAKH,oBAAC;AAAD,CAAC,AAhID,IAgIC;AAhIY,sCAAa","sourcesContent":["import {INativeAudioMetadata, IOptions} from \"./\";\nimport {ID3v2Parser} from \"./id3v2/ID3v2Parser\";\nimport {ID3v1Parser} from \"./id3v1/ID3v1Parser\";\nimport {APEv2Parser} from \"./apev2/APEv2Parser\";\nimport {AsfParser} from \"./asf/AsfParser\";\nimport {FlacParser} from \"./flac/FlacParser\";\nimport {MP4Parser} from \"./mp4/MP4Parser\";\nimport {OggParser} from \"./ogg/OggParser\";\nimport * as strtok3 from \"strtok3\";\nimport {StringType} from \"token-types\";\nimport {Promise} from \"es6-promise\";\nimport * as Stream from \"stream\";\nimport * as path from \"path\";\nimport {AIFFParser} from \"./aiff/AiffParser\";\n\nexport interface ITokenParser {\n  parse(tokenizer: strtok3.ITokenizer, options: IOptions): Promise<INativeAudioMetadata>;\n}\n\nexport class ParserFactory {\n\n  /**\n   * Extract metadata from the given audio file\n   * @param filePath File path of the audio file to parse\n   * @param opts\n   *   .fileSize=true  Return filesize\n   *   .native=true    Will return original header in result\n   * @returns {Promise<INativeAudioMetadata>}\n   */\n  public static parseFile(filePath: string, opts: IOptions = {}): Promise<INativeAudioMetadata> {\n\n    return strtok3.fromFile(filePath).then((fileTokenizer) => {\n      return ParserFactory.getParserForExtension(filePath).then((parser) => {\n        return parser.parse(fileTokenizer, opts).then((metadata) => {\n          return fileTokenizer.close().then(() => {\n            return metadata;\n          });\n        });\n      }).catch((err) => {\n        return fileTokenizer.close().then(() => {\n          throw err;\n        });\n      });\n    });\n  }\n\n  /**\n   * Parse metadata from stream\n   * @param stream\n   * @param mimeType The mime-type, e.g. \"audio/mpeg\". This is used to redirect to the correct parser.\n   * @param opts Parsing options\n   * @returns {Promise<INativeAudioMetadata>}\n   */\n  public static parseStream(stream: Stream.Readable, mimeType: string, opts: IOptions = {}): Promise<INativeAudioMetadata> {\n\n    return strtok3.fromStream(stream).then((tokenizer) => {\n      if (!tokenizer.fileSize && opts.fileSize) {\n        tokenizer.fileSize = opts.fileSize;\n      }\n\n      return ParserFactory.getParserForMimeType(mimeType).then((parser) => {\n        return parser.parse(tokenizer, opts);\n      });\n    });\n  }\n\n  /**\n   * @param filePath Path to audio file\n   */\n  private static getParserForExtension(filePath: string): Promise<ITokenParser> {\n    const extension = path.extname(filePath).toLocaleLowerCase();\n    switch (extension) {\n\n      case '.mp3':\n        return this.hasStartTag(filePath, 'ID3').then((hasID3) => {\n          return hasID3 ? new ID3v2Parser() : new ID3v1Parser();\n        });\n\n      case '.ape':\n        return Promise.resolve<ITokenParser>(new APEv2Parser());\n\n      case '.aac':\n      case '.mp4':\n      case '.m4a':\n        return Promise.resolve<ITokenParser>(new MP4Parser());\n\n      case '.wma':\n      case '.wmv':\n      case '.asf':\n        return Promise.resolve<ITokenParser>(new AsfParser());\n\n      case '.flac':\n        return Promise.resolve<ITokenParser>(new FlacParser());\n\n      case '.ogg':\n        return Promise.resolve<ITokenParser>(new OggParser());\n\n      case '.aiff':\n        return Promise.resolve<ITokenParser>(new AIFFParser());\n\n      default:\n        throw new Error(\"Extension \" + extension + \" not supported.\");\n    }\n  }\n\n  private static getParserForMimeType(mimeType: string): Promise<ITokenParser> {\n    switch (mimeType) {\n\n      case 'audio/mpeg':\n        return Promise.resolve<ITokenParser>(new ID3v2Parser()); // ToDo: handle ID1 header as well\n\n      case 'audio/x-monkeys-audio':\n        return Promise.resolve<ITokenParser>(new APEv2Parser());\n\n      case 'audio/mp4':\n        return Promise.resolve<ITokenParser>(new MP4Parser());\n\n      case 'audio/x-ms-wma':\n        return Promise.resolve<ITokenParser>(new AsfParser());\n\n      case 'audio/flac':\n        return Promise.resolve<ITokenParser>(new FlacParser());\n\n      case 'audio/ogg':\n        return Promise.resolve<ITokenParser>(new OggParser());\n\n      case 'audio/aac':\n      case 'audio/aacp':\n        return Promise.resolve<ITokenParser>(new MP4Parser());\n\n      default:\n        throw new Error(\"MIME-Type: \" + mimeType + \" not supported.\");\n    }\n  }\n\n  // ToDo: obsolete\n  private static hasStartTag(filePath: string, tagIdentifier: string): Promise<boolean> {\n    return strtok3.fromFile(filePath).then((tokenizer) => {\n      return tokenizer.readToken(new StringType(tagIdentifier.length, 'ascii')).then((token) => {\n        return token === tagIdentifier;\n      });\n    });\n  }\n\n  // ToDo: expose warnings to API\n  private warning: string[] = [];\n\n}\n"]}