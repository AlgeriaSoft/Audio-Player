{"version":3,"file":"APEv2Parser.js","sourceRoot":"","sources":["../../src/apev2/APEv2Parser.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict';\n\nimport common from '../common';\nimport {HeaderType} from '../tagmap';\nimport {INativeAudioMetadata, IOptions, IFormat} from \"../\";\nimport {ITokenParser} from \"../ParserFactory\";\nimport {ITokenizer, IgnoreType} from \"strtok3\";\nimport {BufferType, StringType} from \"token-types\";\nimport * as Token from \"token-types\";\n\n/**\n * APETag versionIndex history / supported formats\n *\n *  1.0 (1000) - Original APE tag spec.  Fully supported by this code.\n *  2.0 (2000) - Refined APE tag spec (better streaming support, UTF encoding). Fully supported by this code.\n *\n *  Notes:\n *  - also supports reading of ID3v1.1 tags\n *  - all saving done in the APE Tag format using CURRENT_APE_TAG_VERSION\n *\n * APE File Format Overview: (pieces in order -- only valid for the latest versionIndex APE files)\n *\n * JUNK - any amount of \"junk\" before the APE_DESCRIPTOR (so people that put ID3v2 tags on the files aren't hosed)\n * APE_DESCRIPTOR - defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n * APE_HEADER - describes all of the necessary information about the APE file\n * SEEK TABLE - the table that represents seek offsets [optional]\n * HEADER DATA - the pre-audio data from the original file [optional]\n * APE FRAMES - the actual compressed audio (broken into frames for seekability)\n * TERMINATING DATA - the post-audio data from the original file [optional]\n * TAG - describes all the properties of the file [optional]\n */\n\ninterface IDescriptor {\n  // should equal 'MAC '\n  ID: string,\n  // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n  version: number,\n  // the number of descriptor bytes (allows later expansion of this header)\n  descriptorBytes: number,\n  // the number of header APE_HEADER bytes\n  headerBytes: number,\n  // the number of header APE_HEADER bytes\n  seekTableBytes: number,\n  // the number of header data bytes (from original file)\n  headerDataBytes: number,\n  // the number of bytes of APE frame data\n  apeFrameDataBytes: number,\n  // the high order number of APE frame data bytes\n  apeFrameDataBytesHigh: number,\n  // the terminating data of the file (not including tag data)\n  terminatingDataBytes: number,\n  // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n  fileMD5: Buffer\n}\n\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexport interface IHeader {\n  // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n  compressionLevel: number,\n  // any format flags (for future use)\n  formatFlags: number,\n  // the number of audio blocks in one frame\n  blocksPerFrame: number,\n  // the number of audio blocks in the final frame\n  finalFrameBlocks: number,\n  // the total number of frames\n  totalFrames: number,\n  // the bits per sample (typically 16)\n  bitsPerSample: number,\n  // the number of channels (1 or 2)\n  channel: number,\n  // the sample rate (typically 44100)\n  sampleRate: number\n}\n\ninterface IFooter {\n  // should equal 'APETAGEX'\n  ID: string,\n  // equals CURRENT_APE_TAG_VERSION\n  version: number,\n  // the complete size of the tag, including this footer (excludes header)\n  size: number,\n  // the number of fields in the tag\n  fields: number,\n  // reserved for later use (must be zero)\n  reserved: Buffer // ToDo: what is this???\n}\n\ninterface ITagFlags {\n  containsHeader: boolean,\n  containsFooter: boolean,\n  isHeader: boolean,\n  readOnly: boolean,\n  dataType: DataType\n}\n\nenum DataType {\n  text_utf8 = 0,\n  binary = 1,\n  external_info = 2,\n  reserved = 3\n}\n\nclass Structure {\n  /**\n   * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n   */\n  public static DescriptorParser: Token.IGetToken<IDescriptor> = {\n    len: 52,\n\n    get: (buf, off) => {\n      return {\n        // should equal 'MAC '\n        ID: new StringType(4, 'ascii').get(buf, off),\n        // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n        version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n        // the number of descriptor bytes (allows later expansion of this header)\n        descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n        // the number of header APE_HEADER bytes\n        headerBytes: Token.UINT32_LE.get(buf, off + 12),\n        // the number of header APE_HEADER bytes\n        seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n        // the number of header data bytes (from original file)\n        headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n        // the number of bytes of APE frame data\n        apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n        // the high order number of APE frame data bytes\n        apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n        // the terminating data of the file (not including tag data)\n        terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n        // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n        fileMD5: new BufferType(16).get(buf, off + 36)\n      };\n    }\n  };\n\n  /**\n   * APE_HEADER: describes all of the necessary information about the APE file\n   */\n  public static Header = {\n    len: 24,\n\n    get: (buf, off) => {\n      return {\n        // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n        compressionLevel: Token.UINT16_LE.get(buf, off),\n        // any format flags (for future use)\n        formatFlags: Token.UINT16_LE.get(buf, off + 2),\n        // the number of audio blocks in one frame\n        blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n        // the number of audio blocks in the final frame\n        finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n        // the total number of frames\n        totalFrames: Token.UINT32_LE.get(buf, off + 12),\n        // the bits per sample (typically 16)\n        bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n        // the number of channels (1 or 2)\n        channel: Token.UINT16_LE.get(buf, off + 18),\n        // the sample rate (typically 44100)\n        sampleRate: Token.UINT32_LE.get(buf, off + 20)\n      };\n    }\n  };\n\n  /**\n   * TAG: describes all the properties of the file [optional]\n   */\n  public static TagFooter: Token.IGetToken<IFooter> = {\n    len: 32,\n\n    get: (buf, off) => {\n      return {\n        // should equal 'APETAGEX'\n        ID: new StringType(8, 'ascii').get(buf, off),\n        // equals CURRENT_APE_TAG_VERSION\n        version: Token.UINT32_LE.get(buf, off + 8),\n        // the complete size of the tag, including this footer (excludes header)\n        size: Token.UINT32_LE.get(buf, off + 12),\n        // the number of fields in the tag\n        fields: Token.UINT32_LE.get(buf, off + 16),\n        // reserved for later use (must be zero)\n        reserved: new BufferType(12).get(buf, off + 20) // ToDo: what is this???\n      };\n    }\n  };\n\n  public static TagField = (footer) => {\n    return new BufferType(footer.size - Structure.TagFooter.len);\n  }\n\n  public static parseTagFlags(flags): ITagFlags {\n    return {\n      containsHeader: Structure.isBitSet(flags, 31),\n      containsFooter: Structure.isBitSet(flags, 30),\n      isHeader: Structure.isBitSet(flags, 31),\n      readOnly: Structure.isBitSet(flags, 0),\n      dataType: (flags & 6) >> 1\n    };\n  }\n\n  /**\n   * @param num {number}\n   * @param bit 0 is least significant bit (LSB)\n   * @return {boolean} true if bit is 1; otherwise false\n   */\n  public static isBitSet(num, bit): boolean {\n    return (num & 1 << bit) !== 0;\n  }\n\n}\n\ninterface IApeInfo {\n  descriptor?: IDescriptor,\n  header?: IHeader,\n  footer?: IFooter\n}\n\nexport class APEv2Parser implements ITokenParser {\n\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n  public static calculateDuration(ah: IHeader): number {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n\n  private static parseTags(footer: IFooter, buffer: Buffer, includeCovers: boolean): Array<{ id: string, value: any }> {\n    let offset = 0;\n\n    const tags: Array<{ id: string, value: any }> = [];\n\n    for (let i = 0; i < footer.fields; i++) {\n      const size = Token.UINT32_LE.get(buffer, offset);\n      offset += 4;\n      const flags = Structure.parseTagFlags(Token.UINT32_LE.get(buffer, offset));\n      offset += 4;\n\n      let zero = common.findZero(buffer, offset, buffer.length);\n      const key = buffer.toString('ascii', offset, zero);\n      offset = zero + 1;\n\n      switch (flags.dataType) {\n        case DataType.text_utf8: { // utf-8 textstring\n          const value = buffer.toString('utf8', offset, offset += size);\n          const values = value.split(/\\x00/g);\n\n          /*jshint loopfunc:true */\n          for (const val of values) {\n            tags.push({id: key, value: val});\n          }\n          break;\n        }\n\n        case DataType.binary: // binary (probably artwork)\n          if (includeCovers && (key === 'Cover Art (Front)' || key === 'Cover Art (Back)')) {\n            const picData = buffer.slice(offset, offset + size);\n\n            let off = 0;\n            zero = common.findZero(picData, off, picData.length);\n            const description = picData.toString('utf8', off, zero);\n            off = zero + 1;\n\n            const picture = {\n              description,\n              data: new Buffer(picData.slice(off))\n            };\n\n            offset += size;\n            tags.push({id: key, value: picture});\n          }\n          break;\n\n        default:\n          throw new Error('Unexpected data-type: ' + flags.dataType);\n      }\n    }\n    return tags;\n  }\n\n  private type: HeaderType = 'APEv2'; // ToDo: versionIndex should be made dynamic, APE may also contain ID3\n\n  private ape: IApeInfo = {};\n\n  private tokenizer: ITokenizer;\n  private options: IOptions;\n\n  public parse(tokenizer: ITokenizer, options: IOptions): Promise<INativeAudioMetadata> {\n\n    this.tokenizer = tokenizer;\n    this.options = options;\n\n    return this.tokenizer.readToken(Structure.DescriptorParser)\n      .then((descriptor) => {\n        if (descriptor.ID !== 'MAC ') {\n          throw new Error('Expected MAC on beginning of file'); // ToDo: strip/parse JUNK\n        }\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - Structure.DescriptorParser.len;\n        if (lenExp > 0) {\n          return this.parseDescriptorExpansion(lenExp);\n        } else {\n          return this.parseHeader();\n        }\n      }).then((header) => {\n        return this.tokenizer.readToken(new IgnoreType(header.forwardBytes)).then(() => {\n          return this.parseFooter().then((tags) => {\n            return {\n              format: header.format,\n              native: {\n                APEv2: tags\n              }\n            };\n          });\n        });\n      });\n\n  }\n\n  private parseDescriptorExpansion(lenExp: number): Promise<{ format: IFormat, forwardBytes: number }> {\n    return this.tokenizer.readToken(new IgnoreType(lenExp)).then(() => {\n      return this.parseHeader();\n    });\n  }\n\n  private parseHeader(): Promise<{ format: IFormat, forwardBytes: number }> {\n    return this.tokenizer.readToken(Structure.Header).then((header) => {\n      return {\n        format: {\n          // dataformat: 'ape',\n          lossless: true,\n          headerType: this.type,\n          bitsPerSample: header.bitsPerSample,\n          sampleRate: header.sampleRate,\n          numberOfChannels: header.channel,\n          duration: APEv2Parser.calculateDuration(header)\n        },\n        forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n        this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n      };\n    });\n  }\n\n  private parseFooter(): Promise<Array<{ id: string, value: any }>> {\n    return this.tokenizer.readToken<IFooter>(Structure.TagFooter).then((footer) => {\n      if (footer.ID !== 'APETAGEX') {\n        throw new Error('Expected footer to start with APETAGEX ');\n      }\n      return this.tokenizer.readToken<Buffer>(Structure.TagField(footer)).then((tags) => {\n        return APEv2Parser.parseTags(footer, tags, !this.options.skipCovers);\n      });\n    });\n  }\n}\n"]}