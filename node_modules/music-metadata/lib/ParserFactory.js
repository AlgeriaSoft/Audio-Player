"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ID3v2Parser_1 = require("./id3v2/ID3v2Parser");
var ID3v1Parser_1 = require("./id3v1/ID3v1Parser");
var APEv2Parser_1 = require("./apev2/APEv2Parser");
var AsfParser_1 = require("./asf/AsfParser");
var FlacParser_1 = require("./flac/FlacParser");
var MP4Parser_1 = require("./mp4/MP4Parser");
var OggParser_1 = require("./ogg/OggParser");
var strtok3 = require("strtok3");
var token_types_1 = require("token-types");
var es6_promise_1 = require("es6-promise");
var path = require("path");
var AiffParser_1 = require("./aiff/AiffParser");
var ParserFactory = (function () {
    function ParserFactory() {
        // ToDo: expose warnings to API
        this.warning = [];
    }
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .fileSize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseFile = function (filePath, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromFile(filePath).then(function (fileTokenizer) {
            return ParserFactory.getParserForExtension(filePath).then(function (parser) {
                return parser.parse(fileTokenizer, opts).then(function (metadata) {
                    return fileTokenizer.close().then(function () {
                        return metadata;
                    });
                });
            }).catch(function (err) {
                return fileTokenizer.close().then(function () {
                    throw err;
                });
            });
        });
    };
    /**
     * Parse metadata from stream
     * @param stream
     * @param mimeType The mime-type, e.g. "audio/mpeg". This is used to redirect to the correct parser.
     * @param opts Parsing options
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseStream = function (stream, mimeType, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromStream(stream).then(function (tokenizer) {
            if (!tokenizer.fileSize && opts.fileSize) {
                tokenizer.fileSize = opts.fileSize;
            }
            return ParserFactory.getParserForMimeType(mimeType).then(function (parser) {
                return parser.parse(tokenizer, opts);
            });
        });
    };
    /**
     * @param filePath Path to audio file
     */
    ParserFactory.getParserForExtension = function (filePath) {
        var extension = path.extname(filePath).toLocaleLowerCase();
        switch (extension) {
            case '.mp3':
                return this.hasStartTag(filePath, 'ID3').then(function (hasID3) {
                    return hasID3 ? new ID3v2Parser_1.ID3v2Parser() : new ID3v1Parser_1.ID3v1Parser();
                });
            case '.ape':
                return es6_promise_1.Promise.resolve(new APEv2Parser_1.APEv2Parser());
            case '.aac':
            case '.mp4':
            case '.m4a':
                return es6_promise_1.Promise.resolve(new MP4Parser_1.MP4Parser());
            case '.wma':
            case '.wmv':
            case '.asf':
                return es6_promise_1.Promise.resolve(new AsfParser_1.AsfParser());
            case '.flac':
                return es6_promise_1.Promise.resolve(new FlacParser_1.FlacParser());
            case '.ogg':
                return es6_promise_1.Promise.resolve(new OggParser_1.OggParser());
            case '.aiff':
                return es6_promise_1.Promise.resolve(new AiffParser_1.AIFFParser());
            default:
                throw new Error("Extension " + extension + " not supported.");
        }
    };
    ParserFactory.getParserForMimeType = function (mimeType) {
        switch (mimeType) {
            case 'audio/mpeg':
                return es6_promise_1.Promise.resolve(new ID3v2Parser_1.ID3v2Parser()); // ToDo: handle ID1 header as well
            case 'audio/x-monkeys-audio':
                return es6_promise_1.Promise.resolve(new APEv2Parser_1.APEv2Parser());
            case 'audio/mp4':
                return es6_promise_1.Promise.resolve(new MP4Parser_1.MP4Parser());
            case 'audio/x-ms-wma':
                return es6_promise_1.Promise.resolve(new AsfParser_1.AsfParser());
            case 'audio/flac':
                return es6_promise_1.Promise.resolve(new FlacParser_1.FlacParser());
            case 'audio/ogg':
                return es6_promise_1.Promise.resolve(new OggParser_1.OggParser());
            case 'audio/aac':
            case 'audio/aacp':
                return es6_promise_1.Promise.resolve(new MP4Parser_1.MP4Parser());
            default:
                throw new Error("MIME-Type: " + mimeType + " not supported.");
        }
    };
    // ToDo: obsolete
    ParserFactory.hasStartTag = function (filePath, tagIdentifier) {
        return strtok3.fromFile(filePath).then(function (tokenizer) {
            return tokenizer.readToken(new token_types_1.StringType(tagIdentifier.length, 'ascii')).then(function (token) {
                return token === tagIdentifier;
            });
        });
    };
    return ParserFactory;
}());
exports.ParserFactory = ParserFactory;
//# sourceMappingURL=ParserFactory.js.map