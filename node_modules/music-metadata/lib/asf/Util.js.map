{"version":3,"file":"Util.js","sourceRoot":"","sources":["../../src/asf/Util.ts"],"names":[],"mappings":";;AAAA,oCAA+B;AAI/B;IAAA;IAgDA,CAAC;IA9Ce,qBAAgB,GAA9B,UAA+B,CAAS;QACtC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC;IAEa,qBAAgB,GAA9B,UAA+B,GAAG;QAChC,MAAM,CAAC,gBAAM,CAAC,UAAU,CAAC,gBAAM,CAAC,YAAY,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC,CAAC;IAChE,CAAC;IAEa,uBAAkB,GAAhC,UAAiC,GAAW;QAC1C,IAAM,MAAM,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACtC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACjB,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAEa,kBAAa,GAA3B,UAA4B,GAAW;QACrC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;IAEa,mBAAc,GAA5B,UAA6B,GAAW,EAAE,MAAkB;QAAlB,uBAAA,EAAA,UAAkB;QAC1D,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAClC,CAAC;IAEa,mBAAc,GAA5B,UAA6B,GAAW,EAAE,MAAkB;QAAlB,uBAAA,EAAA,UAAkB;QAC1D,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IACxC,CAAC;IAEa,kBAAa,GAA3B,UAA4B,GAAW,EAAE,MAAkB;QAAlB,uBAAA,EAAA,UAAkB;QACzD,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAClC,CAAC;IAEa,iBAAY,GAA1B,UAA2B,MAAc,EAAE,MAAc;QACvD,IAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QAC9D,IAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QACjE,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QAClC,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5C,CAAC;IAEc,qBAAgB,GAAsB;QACnD,IAAI,CAAC,gBAAgB;QACrB,IAAI,CAAC,kBAAkB;QACvB,IAAI,CAAC,aAAa;QAClB,IAAI,CAAC,cAAc;QACnB,IAAI,CAAC,cAAc;QACnB,IAAI,CAAC,aAAa;QAClB,IAAI,CAAC,kBAAkB;KACxB,CAAC;IACJ,WAAC;CAAA,AAhDD,IAgDC;AAhDY,oBAAI","sourcesContent":["import common from '../common';\n\ntype AttributeParser = (buf: Buffer) => boolean | string | number | Buffer;\n\nexport class Util {\n\n  public static getParserForAttr(i: number): AttributeParser {\n    return Util.attributeParsers[i];\n  }\n\n  public static parseUnicodeAttr(buf): string {\n    return common.stripNulls(common.decodeString(buf, 'utf16le'));\n  }\n\n  public static parseByteArrayAttr(buf: Buffer): Buffer {\n    const newBuf = new Buffer(buf.length);\n    buf.copy(newBuf);\n    return newBuf;\n  }\n\n  public static parseBoolAttr(buf: Buffer): boolean {\n    return Util.parseWordAttr(buf) === 1;\n  }\n\n  public static parseDWordAttr(buf: Buffer, offset: number = 0): number {\n    return buf.readUInt32LE(offset);\n  }\n\n  public static parseQWordAttr(buf: Buffer, offset: number = 0): number {\n    return Util.readUInt64LE(buf, offset);\n  }\n\n  public static parseWordAttr(buf: Buffer, offset: number = 0): number {\n    return buf.readUInt16LE(offset);\n  }\n\n  public static readUInt64LE(buffer: Buffer, offset: number): number {\n    const high = buffer.slice(offset, offset + 4).readUInt32LE(0);\n    const low = buffer.slice(offset + 4, offset + 8).readUInt32LE(0);\n    const maxuint32 = Math.pow(2, 32);\n    return ((low * maxuint32) + (high >>> 0));\n  }\n\n  private static attributeParsers: AttributeParser[] = [\n    Util.parseUnicodeAttr,\n    Util.parseByteArrayAttr,\n    Util.parseBoolAttr,\n    Util.parseDWordAttr,\n    Util.parseQWordAttr,\n    Util.parseWordAttr,\n    Util.parseByteArrayAttr\n  ];\n}\n"]}