'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var strtok3_1 = require("strtok3");
var common_1 = require("../common");
var Token = require("token-types");
var token_types_1 = require("token-types");
/**
 * MPEG Audio Layer I/II/III frame header
 * Ref: https://www.mp3-tech.org/programmer/frame_header.html
 * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
 */
var MpegFrameHeader = (function () {
    function MpegFrameHeader(buf, off) {
        // B(20,19): MPEG Audio versionIndex ID
        this.versionIndex = common_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);
        // C(18,17): Layer description
        this.layer = MpegFrameHeader.LayerDescription[common_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];
        if (this.layer === null)
            throw new Error('Invalid MPEG layer');
        // D(16): Protection bit (if true 16-bit CRC follows header)
        this.isProtectedByCRC = !common_1.default.isBitSet(buf, off + 1, 7);
        // E(15,12): Bitrate index
        this.bitrateIndex = common_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);
        // F(11,10): Sampling rate frequency index
        this.sampRateFreqIndex = common_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);
        // G(9): Padding bit
        this.padding = common_1.default.isBitSet(buf, off + 2, 6);
        // H(8): Private bit
        this.privateBit = common_1.default.isBitSet(buf, off + 2, 7);
        // I(7,6): Channel Mode
        this.channelModeIndex = common_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);
        // J(5,4): Mode extension (Only used in Joint stereo)
        this.modeExtension = common_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);
        // K(3): Copyright
        this.isCopyrighted = common_1.default.isBitSet(buf, off + 3, 4);
        // L(2): Original
        this.isOriginalMedia = common_1.default.isBitSet(buf, off + 3, 5);
        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.
        this.emphasis = common_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);
        this.version = MpegFrameHeader.VersionID[this.versionIndex];
        if (this.version === null)
            throw new Error('Invalid MPEG Audio version');
        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
        // Calculate bitrate
        var bitrateInKbps = this.calcBitrate();
        if (!bitrateInKbps) {
            throw new Error('Cannot determine bit-rate');
        }
        this.bitrate = bitrateInKbps === null ? null : bitrateInKbps * 1000;
        // Calculate sampling rate
        this.samplingRate = this.calcSamplingRate();
        if (this.samplingRate == null) {
            throw new Error('Cannot determine sampling-rate');
        }
    }
    MpegFrameHeader.prototype.calcDuration = function (numFrames) {
        return Math.round(numFrames * (this.calcSamplesPerFrame() / this.samplingRate));
    };
    MpegFrameHeader.prototype.calcSamplesPerFrame = function () {
        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
    };
    MpegFrameHeader.prototype.calculateSideInfoLength = function () {
        if (this.layer !== 3)
            return 2;
        if (this.channelModeIndex === 3) {
            // mono
            if (this.version === 1) {
                return 17;
            }
            else if (this.version === 2 || this.version === 2.5) {
                return 9;
            }
        }
        else {
            if (this.version === 1) {
                return 32;
            }
            else if (this.version === 2 || this.version === 2.5) {
                return 17;
            }
        }
    };
    MpegFrameHeader.prototype.calcSlotSize = function () {
        return [null, 4, 1, 1][this.layer];
    };
    MpegFrameHeader.prototype.calcBitrate = function () {
        if (this.bitrateIndex === 0x00)
            return null; // free
        if (this.bitrateIndex === 0x0F)
            return null; // 'reserved'
        var mpegVersion = this.version.toString() + this.layer;
        return MpegFrameHeader.bitrate_index[this.bitrateIndex][mpegVersion];
    };
    MpegFrameHeader.prototype.calcSamplingRate = function () {
        if (this.sampRateFreqIndex === 0x03)
            return null; // 'reserved'
        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
    };
    MpegFrameHeader.SyncByte1 = 0xFF;
    MpegFrameHeader.SyncByte2 = 0xE0;
    MpegFrameHeader.VersionID = [2.5, null, 2, 1];
    MpegFrameHeader.LayerDescription = [null, 3, 2, 1];
    MpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];
    MpegFrameHeader.bitrate_index = {
        0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
    };
    MpegFrameHeader.sampling_rate_freq_index = {
        1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },
        2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },
        2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }
    };
    MpegFrameHeader.samplesInFrameTable = [
        /* Layer   I    II   III */
        [0, 384, 1152, 1152],
        [0, 384, 1152, 576] // MPEG-2(.5
    ];
    return MpegFrameHeader;
}());
/**
 * MPEG Audio Layer I/II/III
 */
var MpegAudioLayer = (function () {
    function MpegAudioLayer() {
    }
    MpegAudioLayer.getVbrCodecProfile = function (vbrScale) {
        return 'V' + (100 - vbrScale) / 10;
    };
    MpegAudioLayer.FrameHeader = {
        len: 4,
        get: function (buf, off) {
            return new MpegFrameHeader(buf, off);
        }
    };
    /**
     * Info Tag: Xing, LAME
     */
    MpegAudioLayer.InfoTagHeaderTag = new token_types_1.StringType(4, 'ascii');
    /**
     * LAME TAG value
     * Did not find any official documentation for this
     * Value e.g.: "3.98.4"
     */
    MpegAudioLayer.LameEncoderVersion = new token_types_1.StringType(6, 'ascii');
    /**
     * Info Tag
     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
     */
    MpegAudioLayer.XingInfoTag = {
        len: 136,
        get: function (buf, off) {
            return {
                // 4 bytes for HeaderFlags
                headerFlags: new token_types_1.BufferType(4).get(buf, off),
                // 100 bytes for entry (NUMTOCENTRIES)
                // numToCentries: new strtok.BufferType(100).get(buf, off + 8),
                // FRAME SIZE
                // frameSize: strtok.UINT32_BE.get(buf, off + 108),
                numFrames: Token.UINT32_BE.get(buf, off + 4),
                numToCentries: new token_types_1.BufferType(100).get(buf, off + 104),
                // the number of header APE_HEADER bytes
                streamSize: Token.UINT32_BE.get(buf, off + 108),
                // the number of header data bytes (from original file)
                vbrScale: Token.UINT32_BE.get(buf, off + 112),
                /**
                 * LAME Tag, extends the Xing header format
                 * First added in LAME 3.12 for VBR
                 * The modified header is also included in CBR files (effective LAME 3.94), with "Info" instead of "XING" near the beginning.
                 */
                //  Initial LAME info, e.g.: LAME3.99r
                encoder: new token_types_1.StringType(9, 'ascii').get(buf, off + 116),
                //  Info Tag
                infoTag: Token.UINT8.get(buf, off + 125) >> 4,
                // VBR method
                vbrMethod: Token.UINT8.get(buf, off + 125) & 0xf
            };
        }
    };
    return MpegAudioLayer;
}());
var MpegParser = (function () {
    function MpegParser(tokenizer, headerSize, readDuration) {
        this.tokenizer = tokenizer;
        this.headerSize = headerSize;
        this.readDuration = readDuration;
        this.frameCount = 0;
        this.countSkipFrameData = 0;
        this.bitrates = [];
        this.unsynced = 0;
        this.warnings = [];
        this.calculateVbrDuration = false;
        this.buf_frame_header = new Buffer(4);
    }
    MpegParser.prototype.parse = function () {
        var _this = this;
        this.format = {
            dataformat: 'mp3',
            lossless: false
        };
        return this.sync().then(function () {
            return _this.format;
        }).catch(function (err) {
            if (err === strtok3_1.EndOfFile) {
                if (_this.calculateVbrDuration) {
                    _this.format.numberOfSamples = _this.frameCount * _this.samplesPerFrame;
                    _this.format.duration = _this.format.numberOfSamples / _this.format.sampleRate;
                }
                return _this.format;
            }
            else {
                throw err;
            }
        });
    };
    MpegParser.prototype.sync = function () {
        var _this = this;
        return this.tokenizer.readBuffer(this.buf_frame_header, 0, 1).then(function () {
            if (_this.buf_frame_header[0] === MpegFrameHeader.SyncByte1) {
                return _this.tokenizer.readBuffer(_this.buf_frame_header, 1, 1).then(function () {
                    if ((_this.buf_frame_header[1] & 0xE0) === 0xE0) {
                        // Synchronized
                        _this.warnings.push("synchronized, after " + _this.unsynced + " bytes of unsynced data");
                        _this.unsynced = 0;
                        return _this.parseAudioFrameHeader(_this.buf_frame_header);
                    }
                    else {
                        _this.unsynced += 2;
                        return _this.sync();
                    }
                });
            }
            else {
                ++_this.unsynced;
                return _this.sync();
            }
        });
    };
    MpegParser.prototype.parseAudioFrameHeader = function (buf_frame_header) {
        var _this = this;
        return this.tokenizer.readBuffer(buf_frame_header, 2, 2).then(function () {
            var header;
            try {
                header = MpegAudioLayer.FrameHeader.get(buf_frame_header, 0);
            }
            catch (err) {
                _this.warnings.push("Parse error: " + err.message);
                return _this.sync();
            }
            // mp3 files are only found in MPEG1/2 Layer 3
            if ((header.version !== 1 && header.version !== 2) || header.layer !== 3) {
                _this.warnings.push("Parse error:  mp3 files are only found in MPEG1/2 Layer 3");
                return _this.sync();
            }
            _this.format.dataformat = 'mp3';
            _this.format.lossless = false;
            _this.format.bitrate = header.bitrate;
            _this.format.sampleRate = header.samplingRate;
            _this.format.numberOfChannels = header.channelMode === 'mono' ? 1 : 2;
            var slot_size = header.calcSlotSize();
            if (slot_size === null) {
                throw new Error('invalid slot_size');
            }
            var samples_per_frame = header.calcSamplesPerFrame();
            var bps = samples_per_frame / 8.0;
            var fsize = (bps * header.bitrate / header.samplingRate) +
                ((header.padding) ? slot_size : 0);
            _this.frame_size = Math.floor(fsize);
            _this.audioFrameHeader = header;
            _this.frameCount++;
            _this.bitrates.push(header.bitrate);
            // xtra header only exists in first frame
            if (_this.frameCount === 1) {
                _this.offset = MpegAudioLayer.FrameHeader.len;
                return _this.skipSideInformation();
            }
            if (_this.frameCount === 3) {
                // the stream is CBR if the first 3 frame bitrates are the same
                if (_this.areAllSame(_this.bitrates)) {
                    // subtract non audio stream data from duration calculation
                    var size = _this.tokenizer.fileSize - _this.headerSize;
                    _this.format.duration = (size * 8) / header.bitrate;
                    _this.format.codecProfile = "CBR";
                    return; // Done
                }
                else if (!_this.readDuration) {
                    return; // Done
                }
            }
            // once we know the file is VBR attach listener to end of
            // stream so we can do the duration calculation when we
            // have counted all the frames
            if (_this.readDuration && _this.frameCount === 4) {
                _this.samplesPerFrame = samples_per_frame;
                _this.calculateVbrDuration = true;
            }
            _this.offset = 4;
            if (header.isProtectedByCRC) {
                return _this.parseCrc();
            }
            else {
                return _this.skipSideInformation();
            }
        });
    };
    MpegParser.prototype.parseCrc = function () {
        var _this = this;
        this.tokenizer.readNumber(Token.INT16_BE).then(function (crc) {
            _this.crc = crc;
        });
        this.offset += 2;
        return this.skipSideInformation();
    };
    MpegParser.prototype.skipSideInformation = function () {
        var _this = this;
        var sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
        // side information
        return this.tokenizer.readToken(new token_types_1.BufferType(sideinfo_length)).then(function () {
            _this.offset += sideinfo_length;
            return _this.readXtraInfoHeader();
        });
    };
    MpegParser.prototype.readXtraInfoHeader = function () {
        var _this = this;
        return this.tokenizer.readToken(MpegAudioLayer.InfoTagHeaderTag).then(function (headerTag) {
            _this.offset += MpegAudioLayer.InfoTagHeaderTag.len; // 12
            switch (headerTag) {
                case 'Info':
                    _this.format.codecProfile = 'CBR';
                    return _this.readXingInfoHeader();
                case 'Xing':
                    return _this.readXingInfoHeader().then(function (infoTag) {
                        _this.format.codecProfile = MpegAudioLayer.getVbrCodecProfile(infoTag.vbrScale);
                        return null;
                    });
                case 'Xtra':
                    // ToDo: ???
                    break;
                case 'LAME':
                    return _this.tokenizer.readToken(MpegAudioLayer.LameEncoderVersion).then(function (version) {
                        _this.offset += MpegAudioLayer.LameEncoderVersion.len;
                        _this.format.encoder = "LAME " + version;
                        return _this.skipFrameData(_this.frame_size - _this.offset);
                    });
            }
            // ToDo: promise duration???
            var frameDataLeft = _this.frame_size - _this.offset;
            return _this.skipFrameData(frameDataLeft);
        });
    };
    /**
     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
     * @returns {Promise<string>}
     */
    MpegParser.prototype.readXingInfoHeader = function () {
        var _this = this;
        return this.tokenizer.readToken(MpegAudioLayer.XingInfoTag).then(function (infoTag) {
            _this.offset += MpegAudioLayer.XingInfoTag.len; // 12
            _this.format.encoder = common_1.default.stripNulls(infoTag.encoder);
            if ((infoTag.headerFlags[3] & 0x01) === 1) {
                _this.format.duration = _this.audioFrameHeader.calcDuration(infoTag.numFrames);
                return infoTag; // Done
            }
            // frames field is not present
            var frameDataLeft = _this.frame_size - _this.offset;
            // ToDo: promise duration???
            return _this.skipFrameData(frameDataLeft).then(function () {
                return infoTag;
            });
        });
    };
    MpegParser.prototype.skipFrameData = function (frameDataLeft) {
        var _this = this;
        return this.tokenizer.readToken(new Token.IgnoreType(frameDataLeft)).then(function () {
            _this.countSkipFrameData += frameDataLeft;
            return _this.sync();
        });
    };
    MpegParser.prototype.areAllSame = function (array) {
        var first = array[0];
        return array.every(function (element) {
            return element === first;
        });
    };
    return MpegParser;
}());
exports.MpegParser = MpegParser;
//# sourceMappingURL=MpegParser.js.map