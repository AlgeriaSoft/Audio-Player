{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/* jshint maxlen: 300 */\n'use strict';\n\nimport common from './common';\n\nimport TagMap from './tagmap';\nimport {HeaderType} from './tagmap';\nimport EventEmitter = NodeJS.EventEmitter;\nimport {ParserFactory} from \"./ParserFactory\";\nimport * as Stream from \"stream\";\n\nexport interface IPicture {\n  format: string,\n  data: Buffer;\n}\n\nexport interface ICommonTagsResult {\n  track: { no: number, of: number },\n  disk: { no: number, of: number },\n  /**\n   * Release year\n   */\n  year?: number,\n  title?: string,\n  artist?: string, // ToDo: string[] is only used internal\n  artists?: string[],\n  albumartist?: string,\n  album?: string,\n  /**\n   * Release data\n   */\n  date?: string,\n  /**\n   * Original release date\n   */\n  originaldate?: string,\n  /**\n   * Original release yeat\n   */\n  originalyear?: number,\n  comment?: string[],\n  genre?: string[];\n  picture?: IPicture[];\n  composer?: string[];\n  lyrics?: string[],\n  albumsort?: string,\n  titlesort?: string,\n  work?: string,\n  artistsort?: string,\n  albumartistsort?: string,\n  composersort?: string[],\n  lyricist?: string[],\n  writer?: string[],\n  conductor?: string[],\n  remixer?: string[],\n  arranger?: string[],\n  engineer?: string[],\n  producer?: string[],\n  djmixer?: string[],\n  mixer?: string[],\n  label?: string,\n  grouping?: string[],\n  subtitle?: string[],\n  discsubtitle?: string[],\n  totaltracks?: string,\n  totaldiscs?: string,\n  compilation?: string,\n  _rating?: string,\n  bpm?: string,\n  mood?: string,\n  media?: string,\n  catalognumber?: string,\n  show?: string,\n  showsort?: string,\n  podcast?: string,\n  podcasturl?: string,\n  releasestatus?: string,\n  releasetype?: string[],\n  releasecountry?: string,\n  script?: string,\n  language?: string,\n  copyright?: string,\n  license?: string,\n  encodedby?: string,\n  encodersettings?: string,\n  gapless?: string,\n  barcode?: number, // ToDo: multiple??\n  // International Standard Recording Code\n  isrc?: string,\n  asin?: string,\n  musicbrainz_recordingid?: string,\n  musicbrainz_trackid?: string,\n  musicbrainz_albumid?: string,\n  musicbrainz_artistid?: string[],\n  musicbrainz_albumartistid?: string[],\n  musicbrainz_releasegroupid?: string,\n  musicbrainz_workid?: string,\n  musicbrainz_trmid?: string,\n  musicbrainz_discid?: string,\n  acoustid_id?: string,\n  acoustid_fingerprint?: string,\n  musicip_puid?: string,\n  musicip_fingerprint?: string,\n  website?: string,\n  'performer:instrument'?: string[],\n  averageLevel?: number,\n  peakLevel?: number,\n  notes: string[],\n  originalalbum: string,\n  originalartist: string\n}\n\nexport interface IFormat {\n\n  /**\n   * E.g.: 'flac'\n   */\n  dataformat?: string, // ToDo: make mandatory\n\n  headerType?: HeaderType, // ToDo: make mandatory\n\n  /**\n   * Duration in seconds\n   */\n  duration?: number,\n\n  /**\n   * Number bits per second of encoded audio file\n   */\n  bitrate?: number,\n\n  /**\n   * Sampling rate in Samples per second (S/s)\n   */\n  sampleRate?: number,\n\n  /**\n   * Audio bit depth\n   */\n  bitsPerSample?: number,\n\n  /**\n   * Encoder name, e.g.:\n   */\n  encoder?: string,\n\n  /**\n   * Codec profile\n   */\n  codecProfile?: string,\n\n  lossless?: boolean,\n\n  /**\n   * Number of audio channels\n   */\n  numberOfChannels?: number,\n\n  /**\n   * Number of samples.\n   * One sample contains all channels\n   * The duration is: numberOfSamples / sampleRate\n   */\n  numberOfSamples?: number\n}\n\nexport interface ITag {\n  id: string,\n  value: any\n}\n\n/**\n * Flat list of tags\n */\nexport interface INativeTags { [tagType: string]: ITag[];\n}\n\n/**\n * Tags ordered by tag-ID\n */\nexport interface INativeTagDict { [tagId: string]: any[];\n}\n\nexport interface INativeAudioMetadata {\n  format: IFormat,\n  native: INativeTags\n}\n\nexport interface IAudioMetadata extends INativeAudioMetadata {\n  common: ICommonTagsResult,\n}\n\nexport interface IOptions {\n  path?: string,\n\n  /**\n   *  default: `undefined`, pass the\n   */\n  fileSize?: number,\n\n  /**\n   *  default: `false`, if set to `true`, it will return native tags in addition to the `common` tags.\n   */\n  native?: boolean,\n\n  /**\n   * default: `false`, if set to `true`, it will parse the whole media file if required to determine the duration.\n   */\n  duration?: boolean;\n\n  /**\n   * default: `false`, if set to `true`, it will skip parsing covers.\n   */\n  skipCovers?: boolean;\n}\n\nexport class MusicMetadataParser {\n\n  public static getInstance(): MusicMetadataParser {\n    return new MusicMetadataParser();\n  }\n\n  public static toIntOrNull(str: string): number {\n    const cleaned = parseInt(str, 10);\n    return isNaN(cleaned) ? null : cleaned;\n  }\n\n  // TODO: a string of 1of1 would fail to be converted\n  // converts 1/10 to no : 1, of : 10\n  // or 1 to no : 1, of : 0\n  public static cleanupTrack(origVal: number | string) {\n    const split = origVal.toString().split('/');\n    return {\n      no: parseInt(split[0], 10) || null,\n      of: parseInt(split[1], 10) || null\n    };\n  }\n\n  public static cleanupPicture(picture) {\n    let newFormat;\n    if (picture.format) {\n      const split = picture.format.toLowerCase().split('/');\n      newFormat = (split.length > 1) ? split[1] : split[0];\n      if (newFormat === 'jpeg') newFormat = 'jpg';\n    } else {\n      newFormat = 'jpg';\n    }\n    return {format: newFormat, data: picture.data};\n  }\n\n  /**\n   * ToDo: move to respective format implementations\n   */\n  /*\n  private static headerTypes = [\n    {\n      buf: GUID.HeaderObject.toBin(),\n      tag: require('./asf/AsfParser')\n    },\n    {\n      buf: new Buffer('ID3'),\n      tag: require('./id3v2')\n    },\n    {\n      buf: new Buffer('ftypM4A'),\n      tag: require('./id4'),\n      offset: 4\n    },\n    {\n      buf: new Buffer('ftypmp42'),\n      tag: require('./id4'),\n      offset: 4\n    },\n    {\n      buf: new Buffer('OggS'),\n      tag: require('./ogg')\n    },\n    {\n      buf: new Buffer('fLaC'),\n      tag: require('./flac')\n    },\n    {\n      buf: new Buffer('MAC'),\n      tag: require('./monkeysaudio')\n    }\n  ];*/\n\n  private tagMap = new TagMap();\n\n  /**\n   * Extract metadata from the given audio file\n   * @param filePath File path of the audio file to parse\n   * @param opts\n   *   .filesize=true  Return filesize\n   *   .native=true    Will return original header in result\n   * @returns {Promise<IAudioMetadata>}\n   */\n  public parseFile(filePath: string, opts: IOptions = {}): Promise<IAudioMetadata> {\n\n    return ParserFactory.parseFile(filePath, opts).then((nativeData) => {\n      return this.parseNativeTags(nativeData, opts.native);\n    });\n\n  }\n\n  /**\n   * Extract metadata from the given audio file\n   * @param stream Audio ReadableStream\n   * @param mimeType Mime-Type of Stream\n   * @param opts\n   *   .filesize=true  Return filesize\n   *   .native=true    Will return original header in result\n   * @returns {Promise<IAudioMetadata>}\n   */\n  public parseStream(stream: Stream.Readable, mimeType: string, opts: IOptions = {}): Promise<IAudioMetadata> {\n    return ParserFactory.parseStream(stream, mimeType, opts).then((nativeData) => {\n      return this.parseNativeTags(nativeData, opts.native);\n    });\n  }\n\n  /**\n   * Convert native tags to common tags\n   * @param nativeData\n   * @includeNative return native tags in result\n   * @returns {IAudioMetadata} Native + common tags\n   */\n  public parseNativeTags(nativeData: INativeAudioMetadata, includeNative?: boolean): IAudioMetadata {\n\n    const metadata: IAudioMetadata = {\n      format: nativeData.format,\n      native: includeNative ? nativeData.native : undefined,\n      common: {\n        track: {no: null, of: null},\n        disk: {no: null, of: null}\n      } as any\n    };\n\n    for (const tagType in nativeData.native) {\n      for (const tag of nativeData.native[tagType]) {\n        this.setCommonTags(metadata.common, tagType as HeaderType, tag.id, tag.value);\n      }\n    }\n\n    if (metadata.common.artists && metadata.common.artists.length > 0) {\n      metadata.common.artist = metadata.common.artist[0];\n    } else {\n      if (metadata.common.artist) {\n        metadata.common.artists = metadata.common.artist as any;\n        if (metadata.common.artist.length > 1) {\n          delete metadata.common.artist;\n        } else {\n          metadata.common.artist = metadata.common.artist[0];\n        }\n      }\n    }\n    return metadata;\n  }\n\n  /**\n   * Process and set common tags\n   * @param comTags Target metadata to wrote common tags to\n   * @param type    Native headerType e.g.: 'iTunes MP4' | 'asf' | 'id3v1.1' | 'id3v2.4' | 'vorbis'\n   * @param tag     Native tag\n   * @param value   Native tag value\n   */\n  private setCommonTags(comTags, type: HeaderType, tag: string, value: any) {\n\n    switch (type) {\n      /*\n       case 'vorbis':\n       switch (tag) {\n\n       case 'TRACKTOTAL':\n       case 'TOTALTRACKS': // rare tag\n       comTags.track.of = MusicMetadataParser.toIntOrNull(value)\n       return\n\n       case 'DISCTOTAL':\n       case 'TOTALDISCS': // rare tag\n       comTags.disk.of = MusicMetadataParser.toIntOrNull(value)\n       return\n       default:\n       }\n       break\n       */\n\n      case 'id3v2.3':\n      case 'id3v2.4':\n        switch (tag) {\n\n          /*\n           case 'TXXX':\n           tag += ':' + value.description\n           value = value.text\n           break*/\n\n          case 'UFID': // decode MusicBrainz Recording Id\n            if (value.owner_identifier === 'http://musicbrainz.org') {\n              tag += ':' + value.owner_identifier;\n              value = common.decodeString(value.identifier, 'iso-8859-1');\n            }\n            break;\n\n          case 'PRIV':\n            switch (value.owner_identifier) {\n              // decode Windows Media Player\n              case 'AverageLevel':\n              case 'PeakValue':\n                tag += ':' + value.owner_identifier;\n                value = common.strtokUINT32_LE.get(value.data, 0);\n                break;\n              default:\n              // Unknown PRIV owner-identifier\n            }\n            break;\n\n          default:\n          // nothing to do\n        }\n        break;\n      default:\n      // nothing to do\n    }\n\n    // Convert native tag event to common (aliased) event\n    const alias = this.tagMap.getCommonName(type, tag);\n\n    if (alias) {\n      // Common tag (alias) found\n\n      // check if we need to do something special with common tag\n      // if the event has been aliased then we need to clean it before\n      // it is emitted to the user. e.g. genre (20) -> Electronic\n      switch (alias) {\n        case 'genre':\n          value = common.parseGenre(value);\n          break;\n\n        case 'barcode':\n          value = typeof value === 'string' ? parseInt(value, 10) : value;\n          break;\n\n        case 'picture':\n          value = MusicMetadataParser.cleanupPicture(value);\n          break;\n\n        case 'totaltracks':\n          comTags.track.of = MusicMetadataParser.toIntOrNull(value);\n          return;\n\n        case 'totaldiscs':\n          comTags.disk.of = MusicMetadataParser.toIntOrNull(value);\n          return;\n\n        case 'track':\n        case 'disk':\n          const of = comTags[alias].of; // store of value, maybe maybe overwritten\n          comTags[alias] = MusicMetadataParser.cleanupTrack(value);\n          comTags[alias].of = of != null ? of : comTags[alias].of;\n          return;\n\n        case 'year':\n        case 'originalyear':\n          value = parseInt(value, 10);\n          break;\n\n        case 'date':\n          // ToDo: be more strict on 'YYYY...'\n          // if (/^\\d{4}\\-(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])$/.test(value)) {\n          comTags.year = parseInt(value.substr(0, 4), 10);\n          break;\n\n        default:\n        // nothing to do\n      }\n\n      if (alias !== 'artist' && TagMap.isSingleton(alias)) {\n        comTags[alias] = value;\n      } else {\n        if (comTags.hasOwnProperty(alias)) {\n          comTags[alias].push(value);\n        } else {\n          // if we haven't previously seen this tag then\n          // initialize it to an array, ready for values to be entered\n          comTags[alias] = [value];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Parse audio file\n * @param filePath Media file to read meta-data from\n * @param options Parsing options:\n *   .native=true    Will return original header in result\n * @returns {Promise<IAudioMetadata>}\n */\nexport function parseFile(filePath: string, options?: IOptions): Promise<IAudioMetadata> {\n  return MusicMetadataParser.getInstance().parseFile(filePath, options);\n}\n\n/**\n * Parse audio Stream\n * @param stream\n * @param mimeType\n * @param opts Parsing options\n *   .native=true    Will return original header in result\n * @returns {Promise<IAudioMetadata>}\n */\nexport function parseStream(stream: Stream.Readable, mimeType: string, opts?: IOptions): Promise<IAudioMetadata> {\n  return MusicMetadataParser.getInstance().parseStream(stream, mimeType, opts);\n}\n\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nexport function orderTags(nativeTags: ITag[]): INativeTagDict {\n  const tags = {};\n  for (const tag of nativeTags) {\n    (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);\n  }\n  return tags;\n}\n"]}