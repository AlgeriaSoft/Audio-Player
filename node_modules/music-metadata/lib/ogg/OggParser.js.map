{"version":3,"file":"OggParser.js","sourceRoot":"","sources":["../../src/ogg/OggParser.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict';\nimport common from '../common';\nimport ReadableStream = NodeJS.ReadableStream;\nimport {ITokenParser} from \"../ParserFactory\";\nimport * as strtok3 from \"strtok3\";\nimport {INativeAudioMetadata, IOptions} from \"../index\";\nimport {Readable} from \"stream\";\nimport {Promise} from \"es6-promise\";\nimport {StreamReader} from \"then-read-stream\";\nimport * as Token from \"token-types\";\nimport {VorbisParser} from \"../vorbis/VorbisParser\";\n\n/**\n * Page header\n * Ref: https://www.xiph.org/ogg/doc/framing.html#page_header\n */\ninterface IOggPageHeader {\n  /**\n   * capture_pattern\n   * A header begins with a capture pattern that simplifies identifying pages;\n   * once the decoder has found the capture pattern it can do a more intensive job of verifying that it has in fact found a page boundary (as opposed to an inadvertent coincidence in the byte stream).\n   */\n  capturePattern: string,\n  /**\n   * stream_structure_version\n   */\n  version: number,\n  /**\n   * header_type_flag\n   */\n  headerType: {\n    /**\n     * True: continued packet;\n     * False: fresh packet\n     */\n    continued: boolean,\n\n    /**\n     * True: first page of logical bitstream (bos)\n     * False: not first page of logical bitstream\n     */\n    firstPage: boolean,\n\n    /**\n     * True: last page of logical bitstream (eos)\n     * False: not last page of logical bitstream\n     */\n    lastPage: boolean\n  },\n  /**\n   * The total samples encoded after including all packets finished on this page\n   * The position specified in the frame header of the last page tells how long the data coded by the bitstream is.\n   */\n  absoluteGranulePosition: number,\n  streamSerialNumber: number,\n  pageSequenceNo: number,\n  pageChecksum: number,\n  segmentTable: number;\n}\n\nclass VorbisStream extends Readable {\n\n  private queue: Buffer[] = [];\n  private waitingForData: boolean = false;\n\n  public append(vorbisData: Buffer) {\n    this.queue.push(vorbisData);\n    this._tryPush();\n  }\n\n  public _read() {\n    this.waitingForData = true;\n    this._tryPush();\n  }\n\n  private _tryPush() {\n    while (this.waitingForData) {\n      const buf = this.queue.shift();\n      if (buf) {\n        this.waitingForData = this.push(buf);\n      } else break;\n    }\n  }\n}\n\nexport class OggParser implements ITokenParser {\n\n  public static getInstance(): OggParser {\n    return new OggParser();\n  }\n\n  private static Header: Token.IGetToken<IOggPageHeader> = {\n    len: 27,\n\n    get: (buf, off): IOggPageHeader => {\n      return {\n        capturePattern: new Token.StringType(4, 'ascii').get(buf, off),\n        version: buf.readUInt8(off + 4),\n\n        headerType: {\n          continued: common.strtokBITSET.get(buf, off + 5, 0),\n          firstPage: common.strtokBITSET.get(buf, off + 5, 1),\n          lastPage: common.strtokBITSET.get(buf, off + 5, 2)\n        },\n        // packet_flag: buf.readUInt8(off + 5),\n        absoluteGranulePosition: (buf.readUInt32LE(off + 10) << 32) + buf.readUInt32LE(off + 6),\n        streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n        pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n        pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n        segmentTable: buf.readUInt8(off + 26)\n      };\n    }\n  };\n\n  private tokenizer: strtok3.ITokenizer;\n\n  private vorbisParser: VorbisParser;\n\n  private header: IOggPageHeader;\n  private pageNumber: number;\n  private vorbisStream: VorbisStream;\n\n  public parse(tokenizer: strtok3.ITokenizer, options: IOptions): Promise<INativeAudioMetadata> {\n\n    this.tokenizer = tokenizer;\n    this.vorbisParser = new VorbisParser();\n\n    this.vorbisStream = new VorbisStream();\n    return strtok3.fromStream(this.vorbisStream).then((vorbisTokenizer) => {\n      // ToDo: should be provided with level-2 tokenizer\n      const vorbis = this.vorbisParser.parse(vorbisTokenizer, options).then((metadata) => {\n\n        if (metadata.format.sampleRate) {\n          // Calculate duration\n          metadata.format.duration = this.header.absoluteGranulePosition / metadata.format.sampleRate;\n        }\n\n        return metadata;\n      });\n\n      const ogg = this.parsePage().catch((err) => {\n        if (err === StreamReader.EndOfStream) {\n          // console.log(\"EndOfStream: ogg\");\n          this.vorbisStream.append(null);\n        } else throw err;\n      }).catch((err) => {\n        if (err === strtok3.EndOfFile)\n          return;\n        else throw err;\n      });\n\n      return Promise.all<INativeAudioMetadata, void>([vorbis, ogg]).then(([metadata]) => {\n        return metadata;\n      });\n\n    });\n  }\n\n  private parsePage(): Promise<void> {\n    return this.tokenizer.readToken<IOggPageHeader>(OggParser.Header).then((header) => {\n      if (header.capturePattern !== 'OggS') { // Capture pattern\n        throw new Error('expected ogg header but was not found');\n      }\n      this.header = header;\n\n      this.pageNumber = header.pageSequenceNo;\n\n      return this.tokenizer.readToken<Buffer>(new Token.BufferType(header.segmentTable)).then((segments) => {\n        const pageLength = common.sum(segments as any);\n        return this.tokenizer.readToken<Buffer>(new Token.BufferType(pageLength)).then((pageData) => {\n          this.vorbisStream.append(pageData);\n          return this.parsePage();\n        });\n      });\n    });\n  }\n\n}\n"]}