"use strict";
exports.__esModule = true;
var es6_promise_1 = require("es6-promise");
var Deferred = (function () {
    function Deferred() {
        var _this = this;
        this.promise = new es6_promise_1.Promise(function (resolve, reject) {
            _this.reject = reject;
            _this.resolve = resolve;
        });
    }
    return Deferred;
}());
var StreamReader = (function () {
    function StreamReader(s) {
        var _this = this;
        this.s = s;
        this.endOfStream = false;
        this.s.once("end", function () {
            _this.endOfStream = true;
            if (_this.request) {
                _this.request.deferred.reject(StreamReader.EndOfStream);
            }
            _this.request = null;
        });
    }
    // Read chunk from stream
    StreamReader.prototype.read = function (buffer, offset, length, position) {
        var _this = this;
        if (position === void 0) { position = null; }
        if (this.request)
            throw new Error("Concurrent read operation");
        var readBuffer = this.s.read(length);
        if (readBuffer) {
            readBuffer.copy(buffer, offset);
            return es6_promise_1.Promise.resolve(length);
        }
        else {
            this.request = {
                buffer: buffer,
                offset: offset,
                length: length,
                position: position,
                deferred: new Deferred()
            };
            this.s.once("readable", function () {
                _this.tryRead();
            });
            return this.request.deferred.promise.then(function (n) {
                _this.request = null;
                return n;
            })["catch"](function (err) {
                _this.request = null;
                throw err;
            });
        }
    };
    StreamReader.prototype.tryRead = function () {
        var _this = this;
        var readBuffer = this.s.read(this.request.length);
        if (readBuffer) {
            readBuffer.copy(this.request.buffer, this.request.offset);
            this.request.deferred.resolve(this.request.length);
        }
        else {
            this.s.once("readable", function () {
                _this.tryRead();
            });
        }
    };
    return StreamReader;
}());
/**
 * Used to reject read if end-of-stream has been reached
 * @type {Error}
 */
StreamReader.EndOfStream = new Error("End-Of-Stream");
exports.StreamReader = StreamReader;
